// File: output/catboard_blinky_host.v
// Generated by MyHDL 1.0dev
// Date: Mon Mar 26 01:27:03 2018


`timescale 1ns/10ps

module catboard_blinky_host (
    clock,
    led,
    uart_tx,
    uart_rx
);
// The LEDs are controlled from the RPi over the UART
// to the FPGA.

input clock;
output [7:0] led;
reg [7:0] led;
output uart_tx;
wire uart_tx;
input uart_rx;

reg [7:0] ledreg;
reg [27:0] memmap_mem_addr;
reg [7:0] tone;
reg glbl_tick_sec;
reg [31:0] memmap_read_data;
reg [31:0] memmap_write_data;
reg memmap_done;
reg memmap_write;
reg memmap_read;
wire glbl_timer_ticks1_reset;
reg [15:0] glbl_timer_ticks1_mscnt;
reg [9:0] glbl_timer_ticks1_seccnt;
reg glbl_timer_ticks1_timer_counter2_overflow;
wire [7:0] uartlite1_fbusrx_read_data;
reg uartlite1_fifobus_write;
wire uartlite1_fbusrx_read;
reg uartlite1_fbusrx_empty;
wire uartlite1_fifobus_empty;
reg uartlite1_baudce16;
reg uartlite1_tx;
wire uartlite1_fifobus_read_valid;
wire uartlite1_rx;
reg uartlite1_baudce;
reg uartlite1_fbustx_full;
reg uartlite1_fifobus_read;
reg [7:0] uartlite1_fifobus_write_data;
wire uartlite1_fbusrx_read_valid;
wire uartlite1_fifobus_full;
wire [7:0] uartlite1_fbustx_write_data;
wire [7:0] uartlite1_fifobus_read_data;
wire uartlite1_fbustx_write;
reg [14:0] uartlite1_uartbaud1_cnt;
reg [3:0] uartlite1_uartbaud1_cnt16;
reg uartlite1_uartrx1_midbit;
reg [7:0] uartlite1_uartrx1_rxbyte;
reg uartlite1_uartrx1_rxinprog;
reg uartlite1_uartrx1_rxd;
reg [7:0] uartlite1_uartrx1_fbusrx_write_data;
reg [1:0] uartlite1_uartrx1_state;
reg [3:0] uartlite1_uartrx1_mcnt;
reg [3:0] uartlite1_uartrx1_bitcnt;
reg uartlite1_uartrx1_fbusrx_write;
reg [7:0] uartlite1_uarttx1_txbyte;
reg uartlite1_uarttx1_fbustx_empty;
reg uartlite1_uarttx1_fbustx_read;
reg [3:0] uartlite1_uarttx1_bitcnt;
reg [2:0] uartlite1_uarttx1_state;
wire [7:0] uartlite1_uarttx1_fbustx_read_data;
reg [2:0] uartlite1_fifo_fast2_nvacant;
reg [2:0] uartlite1_fifo_fast2_ntenant;
reg [1:0] uartlite1_fifo_fast2_addr;
wire uartlite1_fifo_fast2_fbus_clear;
wire uartlite1_fifo_fast2_fbus_read_valid;
reg [2:0] uartlite1_fifo_fast3_nvacant;
reg [2:0] uartlite1_fifo_fast3_ntenant;
reg [1:0] uartlite1_fifo_fast3_addr;
reg uartlite1_fifo_fast3_fbus_full;
wire uartlite1_fifo_fast3_fbus_clear;
reg command_bridge1_ready;
reg [3:0] command_bridge1_state;
reg [7:0] command_bridge1_bytemon;
wire [31:0] command_bridge1_address;
wire [31:0] command_bridge1_data;
reg [3:0] command_bridge1_bb_per_addr;
reg command_bridge1_error;
reg [5:0] command_bridge1_controller_basic1_tocnt;
reg [2:0] command_bridge1_controller_basic1_state;
reg uartlite1_syncro2_staps [0:3-1];
reg [7:0] uartlite1_fifo_fast2_mem [0:4-1];
reg uartlite1_syncro3_staps [0:3-1];
reg [7:0] uartlite1_fifo_fast3_mem [0:4-1];
reg [7:0] command_bridge1_packet [0:12-1];

assign glbl_timer_ticks1_reset = 1'd0;
assign uartlite1_fifo_fast2_fbus_clear = 1'd0;
assign uartlite1_fifo_fast3_fbus_clear = 1'd0;
assign command_bridge1_address[32-1:24] = command_bridge1_packet[2];
assign command_bridge1_address[24-1:16] = command_bridge1_packet[3];
assign command_bridge1_address[16-1:8] = command_bridge1_packet[4];
assign command_bridge1_address[8-1:0] = command_bridge1_packet[5];
assign command_bridge1_data[32-1:24] = command_bridge1_packet[8];
assign command_bridge1_data[24-1:16] = command_bridge1_packet[9];
assign command_bridge1_data[16-1:8] = command_bridge1_packet[10];
assign command_bridge1_data[8-1:0] = command_bridge1_packet[11];


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_GLBL_TIMER_TICKS1_TIMER_COUNTER2_BEH_COUNT
    if (glbl_timer_ticks1_reset == 1) begin
        glbl_timer_ticks1_mscnt <= 0;
    end
    else begin
        if (1'b1) begin
            if (($signed({1'b0, glbl_timer_ticks1_mscnt}) == (50000 - 1))) begin
                glbl_timer_ticks1_mscnt <= 0;
            end
            else begin
                glbl_timer_ticks1_mscnt <= (glbl_timer_ticks1_mscnt + 1);
            end
        end
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_GLBL_TIMER_TICKS1_TIMER_COUNTER2_BEH_OVERFLOW
    if ((1'b1 && ($signed({1'b0, glbl_timer_ticks1_mscnt}) == (50000 - 2)))) begin
        glbl_timer_ticks1_timer_counter2_overflow <= 1'b1;
    end
    else begin
        glbl_timer_ticks1_timer_counter2_overflow <= 1'b0;
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_GLBL_TIMER_TICKS1_TIMER_COUNTER3_BEH_COUNT
    if (glbl_timer_ticks1_reset == 1) begin
        glbl_timer_ticks1_seccnt <= 0;
    end
    else begin
        if (glbl_timer_ticks1_timer_counter2_overflow) begin
            if (($signed({1'b0, glbl_timer_ticks1_seccnt}) == (1000 - 1))) begin
                glbl_timer_ticks1_seccnt <= 0;
            end
            else begin
                glbl_timer_ticks1_seccnt <= (glbl_timer_ticks1_seccnt + 1);
            end
        end
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_GLBL_TIMER_TICKS1_TIMER_COUNTER3_BEH_OVERFLOW
    if ((glbl_timer_ticks1_timer_counter2_overflow && ($signed({1'b0, glbl_timer_ticks1_seccnt}) == (1000 - 2)))) begin
        glbl_tick_sec <= 1'b1;
    end
    else begin
        glbl_tick_sec <= 1'b0;
    end
end



assign uartlite1_rx = uartlite1_syncro2_staps[(3 - 1)];


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_UARTLITE1_SYNCRO2_BEH_SYNC_STAGES
    integer ii;
    uartlite1_syncro2_staps[0] <= uart_rx;
    for (ii=1; ii<3; ii=ii+1) begin
        uartlite1_syncro2_staps[ii] <= uartlite1_syncro2_staps[(ii - 1)];
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_UARTLITE1_UARTBAUD1_BEH_BAUD
    if (glbl_timer_ticks1_reset == 1) begin
        uartlite1_uartbaud1_cnt16 <= 0;
        uartlite1_baudce <= 0;
    end
    else begin
        if (uartlite1_baudce16) begin
            uartlite1_uartbaud1_cnt16 <= (uartlite1_uartbaud1_cnt16 + 1);
            if ((uartlite1_uartbaud1_cnt16 == 0)) begin
                uartlite1_baudce <= 1'b1;
            end
            else begin
                uartlite1_baudce <= 1'b0;
            end
        end
        else begin
            uartlite1_baudce <= 1'b0;
        end
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_UARTLITE1_UARTBAUD1_BEH_BAUD16
    if (glbl_timer_ticks1_reset == 1) begin
        uartlite1_uartbaud1_cnt <= 0;
        uartlite1_baudce16 <= 0;
    end
    else begin
        if ((uartlite1_uartbaud1_cnt >= 15049)) begin
            uartlite1_uartbaud1_cnt <= (uartlite1_uartbaud1_cnt - 15049);
            uartlite1_baudce16 <= 1'b1;
        end
        else begin
            uartlite1_uartbaud1_cnt <= (uartlite1_uartbaud1_cnt + 576);
            uartlite1_baudce16 <= 1'b0;
        end
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_UARTLITE1_UARTRX1_BEH_RX
    if (glbl_timer_ticks1_reset == 1) begin
        uartlite1_uartrx1_bitcnt <= 0;
        uartlite1_uartrx1_fbusrx_write_data <= 0;
        uartlite1_uartrx1_state <= 2'b00;
        uartlite1_uartrx1_rxbyte <= 0;
        uartlite1_uartrx1_fbusrx_write <= 0;
    end
    else begin
        uartlite1_uartrx1_fbusrx_write <= 1'b0;
        case (uartlite1_uartrx1_state)
            2'b00: begin
                if ((uartlite1_uartrx1_midbit && (!uartlite1_rx))) begin
                    uartlite1_uartrx1_state <= 2'b01;
                end
            end
            2'b01: begin
                if (uartlite1_uartrx1_midbit) begin
                    uartlite1_uartrx1_rxbyte[uartlite1_uartrx1_bitcnt] <= uartlite1_rx;
                    uartlite1_uartrx1_bitcnt <= (uartlite1_uartrx1_bitcnt + 1);
                end
                else if ((uartlite1_uartrx1_bitcnt == 8)) begin
                    uartlite1_uartrx1_state <= 2'b10;
                    uartlite1_uartrx1_bitcnt <= 0;
                end
            end
            2'b10: begin
                if (uartlite1_uartrx1_midbit) begin
                    uartlite1_uartrx1_state <= 2'b11;
                    uartlite1_uartrx1_fbusrx_write <= 1'b1;
                    uartlite1_uartrx1_fbusrx_write_data <= uartlite1_uartrx1_rxbyte;
                end
            end
            2'b11: begin
                uartlite1_uartrx1_state <= 2'b00;
                uartlite1_uartrx1_bitcnt <= 0;
            end
        endcase
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_UARTLITE1_UARTRX1_BEH_MID
    uartlite1_uartrx1_rxd <= uartlite1_rx;
    if (((uartlite1_uartrx1_rxd && (!uartlite1_rx)) && (uartlite1_uartrx1_state == 2'b00))) begin
        uartlite1_uartrx1_mcnt <= 0;
        uartlite1_uartrx1_rxinprog <= 1'b1;
    end
    else if ((uartlite1_uartrx1_rxinprog && (uartlite1_uartrx1_state == 2'b11))) begin
        uartlite1_uartrx1_rxinprog <= 1'b0;
    end
    else if (uartlite1_baudce16) begin
        uartlite1_uartrx1_mcnt <= (uartlite1_uartrx1_mcnt + 1);
    end
    if ((uartlite1_uartrx1_rxinprog && (uartlite1_uartrx1_mcnt == 7) && uartlite1_baudce16)) begin
        uartlite1_uartrx1_midbit <= 1'b1;
    end
    else begin
        uartlite1_uartrx1_midbit <= 1'b0;
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_UARTLITE1_UARTTX1_BEH_TX
    if (glbl_timer_ticks1_reset == 1) begin
        uartlite1_uarttx1_bitcnt <= 0;
        uartlite1_uarttx1_txbyte <= 0;
        uartlite1_uarttx1_state <= 3'b000;
        uartlite1_uarttx1_fbustx_read <= 0;
        uartlite1_tx <= 1;
    end
    else begin
        uartlite1_uarttx1_fbustx_read <= 1'b0;
        case (uartlite1_uarttx1_state)
            3'b000: begin
                if (((!uartlite1_uarttx1_fbustx_empty) && uartlite1_baudce)) begin
                    uartlite1_uarttx1_txbyte <= uartlite1_uarttx1_fbustx_read_data;
                    uartlite1_uarttx1_fbustx_read <= 1'b1;
                    uartlite1_uarttx1_state <= 3'b001;
                end
            end
            3'b001: begin
                if (uartlite1_baudce) begin
                    uartlite1_uarttx1_bitcnt <= 0;
                    uartlite1_tx <= 1'b0;
                    uartlite1_uarttx1_state <= 3'b010;
                end
            end
            3'b010: begin
                if (uartlite1_baudce) begin
                    uartlite1_uarttx1_bitcnt <= (uartlite1_uarttx1_bitcnt + 1);
                    uartlite1_tx <= uartlite1_uarttx1_txbyte[uartlite1_uarttx1_bitcnt];
                end
                else if ((uartlite1_uarttx1_bitcnt == 8)) begin
                    uartlite1_uarttx1_state <= 3'b011;
                    uartlite1_uarttx1_bitcnt <= 0;
                end
            end
            3'b011: begin
                if (uartlite1_baudce) begin
                    uartlite1_tx <= 1'b1;
                    uartlite1_uarttx1_state <= 3'b100;
                end
            end
            3'b100: begin
                if (uartlite1_baudce) begin
                    uartlite1_uarttx1_state <= 3'b000;
                end
            end
            default: begin
                if (1'b0 !== 1) begin
                    $display("*** AssertionError ***");
                end
            end
        endcase
    end
end



assign uartlite1_uarttx1_fbustx_read_data = uartlite1_fifo_fast2_mem[uartlite1_fifo_fast2_addr];


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_UARTLITE1_FIFO_FAST2_BEH_OCCUPANCY
    if (glbl_timer_ticks1_reset == 1) begin
        uartlite1_fifo_fast2_nvacant <= 4;
        uartlite1_fifo_fast2_ntenant <= 0;
    end
    else begin
        if (uartlite1_fifo_fast2_fbus_clear) begin
            uartlite1_fifo_fast2_nvacant <= 4;
            uartlite1_fifo_fast2_ntenant <= 0;
        end
        else if ((uartlite1_uarttx1_fbustx_read && (!uartlite1_fbustx_write))) begin
            uartlite1_fifo_fast2_nvacant <= (uartlite1_fifo_fast2_nvacant + 1);
            uartlite1_fifo_fast2_ntenant <= (uartlite1_fifo_fast2_ntenant - 1);
        end
        else if ((uartlite1_fbustx_write && (!uartlite1_uarttx1_fbustx_read))) begin
            uartlite1_fifo_fast2_nvacant <= (uartlite1_fifo_fast2_nvacant - 1);
            uartlite1_fifo_fast2_ntenant <= (uartlite1_fifo_fast2_ntenant + 1);
        end
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_UARTLITE1_FIFO_FAST2_BEH_FIFO
    if (glbl_timer_ticks1_reset == 1) begin
        uartlite1_fbustx_full <= 0;
        uartlite1_uarttx1_fbustx_empty <= 1;
        uartlite1_fifo_fast2_addr <= 0;
    end
    else begin
        if (uartlite1_fifo_fast2_fbus_clear) begin
            uartlite1_fifo_fast2_addr <= 0;
            uartlite1_uarttx1_fbustx_empty <= 1'b1;
            uartlite1_fbustx_full <= 1'b0;
        end
        else if ((uartlite1_uarttx1_fbustx_read && (!uartlite1_fbustx_write))) begin
            uartlite1_fbustx_full <= 1'b0;
            if ((uartlite1_fifo_fast2_addr == 0)) begin
                uartlite1_uarttx1_fbustx_empty <= 1'b1;
            end
            else begin
                uartlite1_fifo_fast2_addr <= (uartlite1_fifo_fast2_addr - 1);
            end
        end
        else if ((uartlite1_fbustx_write && (!uartlite1_uarttx1_fbustx_read))) begin
            uartlite1_uarttx1_fbustx_empty <= 1'b0;
            if ((!uartlite1_uarttx1_fbustx_empty)) begin
                uartlite1_fifo_fast2_addr <= (uartlite1_fifo_fast2_addr + 1);
            end
            if (($signed({1'b0, uartlite1_fifo_fast2_addr}) == (4 - 2))) begin
                uartlite1_fbustx_full <= 1'b1;
            end
        end
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_UARTLITE1_FIFO_FAST2_BEH_SRL_IN
    integer jj;
    if (uartlite1_fbustx_write) begin
        uartlite1_fifo_fast2_mem[0] <= uartlite1_fbustx_write_data;
        for (jj=1; jj<4; jj=jj+1) begin
            uartlite1_fifo_fast2_mem[jj] <= uartlite1_fifo_fast2_mem[(jj - 1)];
        end
    end
end



assign uartlite1_fifo_fast2_fbus_read_valid = (uartlite1_uarttx1_fbustx_read && (!uartlite1_uarttx1_fbustx_empty));

// Map external UART FIFOBus interface to internal
// Map the external UART FIFOBus interface attribute signals to
// internal RX FIFO interface.

assign uartlite1_fbusrx_read = uartlite1_fifobus_read;
assign uartlite1_fifobus_empty = uartlite1_fbusrx_empty;
assign uartlite1_fifobus_read_data = uartlite1_fbusrx_read_data;
assign uartlite1_fifobus_read_valid = uartlite1_fbusrx_read_valid;



assign uart_tx = uartlite1_syncro3_staps[(3 - 1)];


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_UARTLITE1_SYNCRO3_BEH_SYNC_STAGES
    integer ii;
    uartlite1_syncro3_staps[0] <= uartlite1_tx;
    for (ii=1; ii<3; ii=ii+1) begin
        uartlite1_syncro3_staps[ii] <= uartlite1_syncro3_staps[(ii - 1)];
    end
end



assign uartlite1_fbusrx_read_data = uartlite1_fifo_fast3_mem[uartlite1_fifo_fast3_addr];


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_UARTLITE1_FIFO_FAST3_BEH_OCCUPANCY
    if (glbl_timer_ticks1_reset == 1) begin
        uartlite1_fifo_fast3_nvacant <= 4;
        uartlite1_fifo_fast3_ntenant <= 0;
    end
    else begin
        if (uartlite1_fifo_fast3_fbus_clear) begin
            uartlite1_fifo_fast3_nvacant <= 4;
            uartlite1_fifo_fast3_ntenant <= 0;
        end
        else if ((uartlite1_fbusrx_read && (!uartlite1_uartrx1_fbusrx_write))) begin
            uartlite1_fifo_fast3_nvacant <= (uartlite1_fifo_fast3_nvacant + 1);
            uartlite1_fifo_fast3_ntenant <= (uartlite1_fifo_fast3_ntenant - 1);
        end
        else if ((uartlite1_uartrx1_fbusrx_write && (!uartlite1_fbusrx_read))) begin
            uartlite1_fifo_fast3_nvacant <= (uartlite1_fifo_fast3_nvacant - 1);
            uartlite1_fifo_fast3_ntenant <= (uartlite1_fifo_fast3_ntenant + 1);
        end
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_UARTLITE1_FIFO_FAST3_BEH_FIFO
    if (glbl_timer_ticks1_reset == 1) begin
        uartlite1_fifo_fast3_fbus_full <= 0;
        uartlite1_fbusrx_empty <= 1;
        uartlite1_fifo_fast3_addr <= 0;
    end
    else begin
        if (uartlite1_fifo_fast3_fbus_clear) begin
            uartlite1_fifo_fast3_addr <= 0;
            uartlite1_fbusrx_empty <= 1'b1;
            uartlite1_fifo_fast3_fbus_full <= 1'b0;
        end
        else if ((uartlite1_fbusrx_read && (!uartlite1_uartrx1_fbusrx_write))) begin
            uartlite1_fifo_fast3_fbus_full <= 1'b0;
            if ((uartlite1_fifo_fast3_addr == 0)) begin
                uartlite1_fbusrx_empty <= 1'b1;
            end
            else begin
                uartlite1_fifo_fast3_addr <= (uartlite1_fifo_fast3_addr - 1);
            end
        end
        else if ((uartlite1_uartrx1_fbusrx_write && (!uartlite1_fbusrx_read))) begin
            uartlite1_fbusrx_empty <= 1'b0;
            if ((!uartlite1_fbusrx_empty)) begin
                uartlite1_fifo_fast3_addr <= (uartlite1_fifo_fast3_addr + 1);
            end
            if (($signed({1'b0, uartlite1_fifo_fast3_addr}) == (4 - 2))) begin
                uartlite1_fifo_fast3_fbus_full <= 1'b1;
            end
        end
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_UARTLITE1_FIFO_FAST3_BEH_SRL_IN
    integer jj;
    if (uartlite1_uartrx1_fbusrx_write) begin
        uartlite1_fifo_fast3_mem[0] <= uartlite1_uartrx1_fbusrx_write_data;
        for (jj=1; jj<4; jj=jj+1) begin
            uartlite1_fifo_fast3_mem[jj] <= uartlite1_fifo_fast3_mem[(jj - 1)];
        end
    end
end



assign uartlite1_fbusrx_read_valid = (uartlite1_fbusrx_read && (!uartlite1_fbusrx_empty));

// Map external UART FIFOBus interface to internal
// Map external UART FIFOBus interface attribute signals to
// internal TX FIFO interface.

assign uartlite1_fbustx_write = (uartlite1_fifobus_write & (!uartlite1_fbustx_full));
assign uartlite1_fbustx_write_data = uartlite1_fifobus_write_data;
assign uartlite1_fifobus_full = uartlite1_fbustx_full;


always @(command_bridge1_ready, uartlite1_fifobus_empty) begin: CATBOARD_BLINKY_HOST_COMMAND_BRIDGE1_BEH_FIFO_READ
    if ((command_bridge1_ready && (!uartlite1_fifobus_empty))) begin
        uartlite1_fifobus_read = 1'b1;
    end
    else begin
        uartlite1_fifobus_read = 1'b0;
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_COMMAND_BRIDGE1_CONTROLLER_BASIC1_BEH_SM
    if (glbl_timer_ticks1_reset == 1) begin
        command_bridge1_controller_basic1_tocnt <= 0;
        command_bridge1_controller_basic1_state <= 3'b000;
    end
    else begin
        case (command_bridge1_controller_basic1_state)
            3'b000: begin
                if ((!memmap_done)) begin
                    command_bridge1_controller_basic1_state <= 3'b001;
                end
                else if (memmap_write) begin
                    command_bridge1_controller_basic1_state <= 3'b010;
                end
                else if (memmap_read) begin
                    command_bridge1_controller_basic1_state <= 3'b100;
                end
            end
            3'b001: begin
                if (memmap_done) begin
                    command_bridge1_controller_basic1_tocnt <= 0;
                    if (memmap_write) begin
                        command_bridge1_controller_basic1_state <= 3'b110;
                    end
                    else if (memmap_read) begin
                        command_bridge1_controller_basic1_state <= 3'b101;
                    end
                end
            end
            3'b010: begin
                command_bridge1_controller_basic1_state <= 3'b110;
                command_bridge1_controller_basic1_tocnt <= 0;
            end
            3'b100: begin
                command_bridge1_controller_basic1_state <= 3'b101;
            end
            3'b101: begin
                if (memmap_done) begin
                    command_bridge1_controller_basic1_state <= 3'b110;
                end
            end
            3'b110: begin
                if ((!(memmap_write || memmap_read))) begin
                    command_bridge1_controller_basic1_state <= 3'b000;
                end
            end
            default: begin
                if (1'b0 !== 1) begin
                    $display("*** AssertionError ***");
                end
            end
        endcase
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_COMMAND_BRIDGE1_BEH_STATE_MACHINE
    integer ii;
    reg [8-1:0] bytecnt;
    integer val;
    integer idx;
    if (glbl_timer_ticks1_reset == 1) begin
        uartlite1_fifobus_write <= 0;
        memmap_read <= 0;
        memmap_write <= 0;
        command_bridge1_bytemon <= 0;
        memmap_mem_addr <= 0;
        memmap_write_data <= 0;
        command_bridge1_packet[0] <= 0;
        command_bridge1_packet[1] <= 0;
        command_bridge1_packet[2] <= 0;
        command_bridge1_packet[3] <= 0;
        command_bridge1_packet[4] <= 0;
        command_bridge1_packet[5] <= 0;
        command_bridge1_packet[6] <= 0;
        command_bridge1_packet[7] <= 0;
        command_bridge1_packet[8] <= 0;
        command_bridge1_packet[9] <= 0;
        command_bridge1_packet[10] <= 0;
        command_bridge1_packet[11] <= 0;
        command_bridge1_state <= 4'b0000;
        command_bridge1_error <= 0;
        command_bridge1_ready <= 0;
        uartlite1_fifobus_write_data <= 0;
        command_bridge1_bb_per_addr <= 0;
        bytecnt = 0;
    end
    else begin
        case (command_bridge1_state)
            4'b0000: begin
                command_bridge1_state <= 4'b0001;
                command_bridge1_ready <= 1'b1;
                bytecnt = 0;
            end
            4'b0001: begin
                if (uartlite1_fifobus_read_valid) begin
                    for (ii=0; ii<2; ii=ii+1) begin
                        case (ii)
                            0: idx = 0;
                            default: idx = 7;
                        endcase
                        case (ii)
                            0: val = 222;
                            default: val = 202;
                        endcase
                        if (($signed({1'b0, bytecnt}) == idx)) begin
                            if (($signed({1'b0, uartlite1_fifobus_read_data}) != val)) begin
                                command_bridge1_error <= 1'b1;
                                command_bridge1_state <= 4'b1001;
                            end
                        end
                    end
                    command_bridge1_packet[bytecnt] <= uartlite1_fifobus_read_data;
                    bytecnt = (bytecnt + 1);
                end
                if ((bytecnt == 12)) begin
                    command_bridge1_ready <= 1'b0;
                    command_bridge1_state <= 4'b0010;
                end
            end
            4'b0010: begin
                command_bridge1_bb_per_addr <= command_bridge1_address[32-1:28];
                memmap_mem_addr <= command_bridge1_address[28-1:0];
                if (memmap_done !== 1) begin
                    $display("*** AssertionError ***");
                end
                bytecnt = 0;
                case (command_bridge1_packet[1])
                    'h1: begin
                        command_bridge1_state <= 4'b0101;
                    end
                    'h2: begin
                        memmap_write_data <= command_bridge1_data;
                        command_bridge1_state <= 4'b0011;
                    end
                    default: begin
                        command_bridge1_error <= 1'b1;
                        command_bridge1_state <= 4'b1001;
                    end
                endcase
            end
            4'b0011: begin
                if (memmap_done) begin
                    memmap_write <= 1'b1;
                    command_bridge1_state <= 4'b0100;
                end
            end
            4'b0100: begin
                memmap_write <= 1'b0;
                if (memmap_done) begin
                    command_bridge1_state <= 4'b0101;
                end
            end
            4'b0101: begin
                if (memmap_done) begin
                    memmap_read <= 1'b1;
                    command_bridge1_state <= 4'b0110;
                end
            end
            4'b0110: begin
                memmap_read <= 1'b0;
                if (memmap_done) begin
                    command_bridge1_packet[(8 + 0)] <= memmap_read_data[32-1:24];
                    command_bridge1_packet[(8 + 1)] <= memmap_read_data[24-1:16];
                    command_bridge1_packet[(8 + 2)] <= memmap_read_data[16-1:8];
                    command_bridge1_packet[(8 + 3)] <= memmap_read_data[8-1:0];
                    command_bridge1_state <= 4'b0111;
                end
            end
            4'b0111: begin
                uartlite1_fifobus_write <= 1'b0;
                if ((bytecnt < 12)) begin
                    if ((!uartlite1_fifobus_full)) begin
                        uartlite1_fifobus_write <= 1'b1;
                        uartlite1_fifobus_write_data <= command_bridge1_packet[bytecnt];
                        bytecnt = (bytecnt + 1);
                    end
                    command_bridge1_state <= 4'b1000;
                end
                else begin
                    command_bridge1_state <= 4'b1010;
                end
            end
            4'b1000: begin
                uartlite1_fifobus_write <= 1'b0;
                command_bridge1_state <= 4'b0111;
            end
            4'b1001: begin
                if ((!uartlite1_fifobus_read_valid)) begin
                    command_bridge1_state <= 4'b1010;
                    command_bridge1_ready <= 1'b0;
                end
            end
            4'b1010: begin
                command_bridge1_error <= 1'b0;
                command_bridge1_ready <= 1'b0;
                command_bridge1_state <= 4'b0000;
            end
            default: begin
                if (1'b0 !== 1) begin
                    $display("*** AssertionError ***");
                end
            end
        endcase
        command_bridge1_bytemon <= bytecnt;
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_BEH_LED_CONTROL
    memmap_done <= (!(memmap_write || memmap_read));
    if ((memmap_write && (memmap_mem_addr == 32))) begin
        ledreg <= memmap_write_data;
    end
end


always @(memmap_read, memmap_mem_addr, ledreg) begin: CATBOARD_BLINKY_HOST_BEH_LED_READ
    if ((memmap_read && (memmap_mem_addr == 32))) begin
        memmap_read_data = ledreg;
    end
    else begin
        memmap_read_data = 0;
    end
end


always @(posedge clock) begin: CATBOARD_BLINKY_HOST_BEH_ASSIGN
    if (glbl_tick_sec) begin
        tone <= ((~tone) & 1);
    end
    led <= (ledreg | tone[5-1:0]);
end

endmodule
